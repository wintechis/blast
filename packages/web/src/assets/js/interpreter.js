/**
 * @fileoverview defines helper functions for the JS Interpreter and its API.
 * (https://github.com/NeilFraser/JS-Interpreter)
 * @license https://www.gnu.org/licenses/agpl-3.0.de.html AGPLv3
 */

import Blockly from 'blockly';
import './blocks/index.js';
import './generators/index.js';
import {getThingsLog} from './things.js';

const {Events, JavaScript} = Blockly;

/**
 * Enum for Blast status
 * @enum {string}
 * @public
 */
export const statusValues = {
  READY: 'ready',
  RUNNING: 'running',
  STOPPED: 'stopped',
  ERROR: 'error',
};

/**
 * Stores the current status of the interpreter, set through {@link setStatus}.
 */
let status = statusValues.READY;

/**
 * Stores functions to be invoked when status changes.
 */
export const onStatusChange = {ready: [], running: [], stopped: [], error: []};

/**
 * Sets the current status of the interpreter.
 * @param {string} newStatus new status.
 */
const setStatus = function (newStatus) {
  if (status !== newStatus) {
    status = newStatus;
    for (const func of onStatusChange[status]) {
      func();
    }
  }
};

/**
 * Gets the current status of the interpreter.
 * @return {string} current status.
 */
export const getStatus = function () {
  return status;
};

/**
 * latest JavaScript code generated by Blast.
 * @type {string}
 * @public
 */
let latestCode = '';

/**
 * Getter for latestCode.
 * @return {string} latestCode
 */
export const getLatestCode = function () {
  return latestCode;
};

/**
 * Blast's main workspace.
 * @type {Blockly.workspaceSvg}
 * @public
 */
let workspace = null;

/**
 * Gets the workspace
 * @return {Blockly.Workspace} the workspace
 */
export const getWorkspace = function () {
  return workspace;
};

/**
 * Sets the workspace
 * @param {Blockly.Workspace} ws the workspace
 */
export const setWorkspace = function (ws) {
  workspace = ws;
};

/**
 * Array containing all interval events.
 * @type {!Array<!Number>}
 */
export const intervalEvents = [];

/**
 * Tracks event blocks currently in the workspace,
 * in order to run indefinately if in case there are any.
 * @type {!Array<!Blockly.Block.id>}
 */
export const eventsInWorkspace = [];

/**
 * Stores event handlers of webHID devices, in order to remove them on code completion.
 * @type {!Array<{device: HIDDevice, type: string, fn: function}>}
 */
export const deviceEventHandlers = [];

/**
 * Stores functions to invoke to reset, when the interpreter is stopped.
 */
const cleanUpFunctions = [];

/**
 * Adds a function to {@link cleanUpFunctions} to be invoked when the interpreter
 * @param {function} fn function to add.
 */
export const addCleanUpFunction = function (fn) {
  cleanUpFunctions.push(fn);
};

/**
 * Defines the Interpreter's standard input function.
 */
let stdIn = null;

/**
 * Setter for the Interpreter's standard input function
 * @param {function} fn new stdIn function
 */
export const setStdIn = function (fn) {
  stdIn = fn;
};

/**
 * Getter for the Interpreter's standard input function.
 * @return {function} stdOut
 */
export const getStdIn = function () {
  return stdIn;
};

/**
 * Defines the Interpreters standard output.
 */
let stdOut = console.log;

/**
 * Setter for the Interpreter's standard output function.
 * @param {function} fn the stdEut function.
 */
export const setStdOut = function (fn) {
  stdOut = fn;
};

/**
 * Getter for the Interpreter's standard output function.
 * @return {function} the stdOut function.
 */
export const getStdOut = function () {
  return stdOut;
};

/**
 * Defines the Interpreters standard info output function.
 */
let stdInfo = console.log;

/**
 * Setter for the Interpreter's standard info output function.
 * @param {function} fn the stdInfo function.
 */
export const setStdInfo = function (fn) {
  stdInfo = fn;
};

/**
 * Getter for the Interpreter's standard info output function.
 * @return {function} the stdInfo function.
 */
export const getStdInfo = function () {
  return stdInfo;
};

/**
 * Defines the Interpreters standard error output.
 */
let stdErr = console.error;

/**
 * Setter for the Interpreter's standard error output function.
 * @param {function} fn the stdErr function.
 * @public
 */
export const setStdError = function (fn) {
  stdErr = fn;
};

/**
 * Getter for the Interpreter's standard error output function.
 * @return {function} the stdErr function.
 */
export const getStdError = function () {
  return stdErr;
};

/**
 * removes all event handlers of webHID devices from {@link deviceEventHandlers}
 */
const removeDeviceHandlers = function () {
  for (const handler of deviceEventHandlers) {
    const device = handler.device;
    getThingsLog()('Removing listener', handler.type, device.productName);
    device.removeEventListener(handler.type, handler.fn);
  }
  deviceEventHandlers.length = 0;
};

/**
 * Clears all interval events.
 */
const clearIntervalEvents = function () {
  for (const event of intervalEvents) {
    clearInterval(event);
  }
  intervalEvents.length = 0;
};

/**
 * Reset the JS Interpreter.
 * @public
 */
export const resetInterpreter = function () {
  removeDeviceHandlers();
  clearIntervalEvents();

  for (const func of cleanUpFunctions) {
    func();
  }
  cleanUpFunctions.length = 0;
};

/**
 * Stop the JavaScript execution.
 * @public
 */
export const stopJS = function () {
  globalThis['interpreterExecutionExit'] = true;
  resetInterpreter();
  setStatus(statusValues.STOPPED);
  stdInfo('execution stopped');
};

/**
 * Stop execution and adds an error message to the
 * {@link Blast.Ui.messageOutputContainer}.
 * @param {string=} text optional, a custom error text
 */
export const throwError = function (text) {
  if (!text) {
    text = 'Error executing program - See console for details.';
  }
  globalThis['interpreterExecutionExit'] = true;
  resetInterpreter();
  stdErr(text);
  setStatus(statusValues.ERROR);
};

/**
 * Generate JavaScript Code for the user's block-program.
 * @public
 */
export const generateCode = function () {
  // Generate JavaScript code and parse it.
  latestCode = '';
  latestCode = workspaceToCode(workspace);
};

/**
 * Generate code for all blocks in the workspace to the specified language.
 * @param {!Workspace=} workspace Workspace to generate code from.
 * @return {string} Generated code.
 */
const workspaceToCode = function (workspace) {
  if (!workspace) {
    // Backwards compatibility from before there could be multiple workspaces.
    console.warn('No workspace specified in workspaceToCode call.  Guessing.');
    workspace = getWorkspace();
  }
  let code = [];
  JavaScript.init(workspace);
  const blocks = workspace.getTopBlocks(true);
  // Generate code for state_definition, event and every_seconds blocks first.
  for (const block of blocks) {
    if (
      block.type === 'event' ||
      block.type === 'state_definition' ||
      block.type === 'every_seconds'
    ) {
      const line = JavaScript.blockToCode(block);
      code.push(line);
    }
  }
  // Generate code for remaining blocks.
  for (const block of blocks) {
    if (
      block.type === 'event' ||
      block.type === 'state_definition' ||
      block.type === 'every_seconds'
    ) {
      continue;
    }
    let line = JavaScript.blockToCode(block);
    if (Array.isArray(line)) {
      // Value blocks return tuples of code and operator order.
      // Top-level blocks don't care about operator order.
      line = line[0];
    }
    if (line) {
      if (block.outputConnection) {
        // This block is a naked value.  Ask the language's code generator if
        // it wants to append a semicolon, or something.
        line = JavaScript.scrubNakedValue(line);
        if (JavaScript.STATEMENT_PREFIX && !block.suppressPrefixSuffix) {
          line = JavaScript.injectId(JavaScript.STATEMENT_PREFIX, block) + line;
        }
        if (JavaScript.STATEMENT_SUFFIX && !block.suppressPrefixSuffix) {
          line = line + JavaScript.injectId(JavaScript.STATEMENT_SUFFIX, block);
        }
      }
      code.push(line);
    }
  }
  code = code.join('\n'); // Blank line between each section.
  code = JavaScript.finish(code);
  // Final scrubbing of whitespace.
  code = code.replace(/^\s+\n/, '');
  code = code.replace(/\n\s+$/, '\n');
  code = code.replace(/[ \t]+\n/g, '\n');
  return code;
};

/**
 * Initializes the JS Interpreter.
 * @param {Blockly.workspace} ws the workspace
 */
export const initInterpreter = function (ws) {
  workspace = ws;

  // Load the interpreter now, and upon future changes.
  generateCode();
  workspace.addChangeListener(event => {
    if (!(event instanceof Events.Ui)) {
      // Something changed. Parser needs to be reloaded.
      generateCode();
    }
  });
};

/**
 * Execute the user's code.
 */
export const runJS = async function () {
  globalThis['interpreterExecutionExit'] = false;
  setStatus(statusValues.RUNNING);
  stdInfo('execution started');
  try {
    eval(
      `(async () => {${latestCode} if(${
        eventsInWorkspace.length === 0
      }) {stopJS()}})();`
    );
  } catch (e) {
    throwError(e);
    console.error(e);
  }
};
