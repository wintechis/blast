/**
 * @fileoverview JavaScript for Blast
 * @author derwehr@gmail.com (Thomas Wehr)
 */
'use strict';

/**
 * Blast application namespace
 */
const Blast = {};

/**
 * Blockly's main workspace.
 * @type {Blockly.workspaceSvg}
 */
Blast.workspace = null;

/**
 * is block highlighting paused.
 */
Blast.highlightPause = false;

/**
 * latest JavaScript code generated by Blast.
 */
Blast.latestCode = '';

/**
 * Singleton instance of the JS Interpreter.
 */
Blast.Interpreter = null;

/**
 * Function called to execute JS Interpreter steps.
 */
Blast.runner = null;

/**
 * Number of messages in the Message Output Container.
 */
Blast.messageCounter = 0;

/**
 * Message output Container
 */
Blast.messageOutputContainer = null;

/**
 * Button to start/stop execution of the user's code.
 */
Blast.runButton = null;

/**
 * Container displaying Blast's current status.
 */
Blast.statusContainer = null;

/**
 * Input to defining URIs for safing and loading blocks.
 */
Blast.uriInput = null;

/**
 * Enum for Blast status
 * @enum {string}
 */
Blast.status = {
  READY: 'ready',
  RUNNING: 'running',
  STOPPED: 'stopped',
  ERROR: 'error',
};

/**
 * Play icon used for the start/stop button.
 */
Blast.playIcon = '<svg class="icon icon-play">';
Blast.playIcon += '<use xlink:href="media/symbol-defs.svg#icon-play"></use>';
Blast.playIcon += '</svg>';

/**
 * Stop icon used for the start/stop button.
 */
Blast.stopIcon = '<svg class="icon icon-stop">';
Blast.stopIcon += '<use xlink:href="media/symbol-defs.svg#icon-stop">';
Blast.stopIcon += '</use></svg>';

/**
 * Load blocks saved on App Engine Storage or in session/local storage.
 * @param {string} xml Text representation of blocks.
 */
Blast.loadBlocks = async function() {
  Blockly.hideChaff();
  // stop execution
  Blast.resetInterpreter();
  Blast.resetUi(Blast.status.READY);

  const url = document.getElementById('loadWorkspace-input').value;
  // send GET request
  fetch(url)
      .then((response) => response.text())
      .then((xmlText) => {
      // clear blocks
        Blast.workspace.clear();

        const xmlDom = Blockly.Xml.textToDom(xmlText);
        Blockly.Xml.domToWorkspace(xmlDom, Blast.workspace);
      })
      .catch((error) => {
        Blockly.alert('Error loading workspace, see console for details.');
        console.error(error);
      });
};

/**
 * Save the current workspace to URL defined in input.
 */
Blast.saveBlocks = function() {
  Blockly.hideChaff();
  const url = document.getElementById('loadWorkspace-input').value;
  // Generate Block XML
  const xmlDom = Blockly.Xml.workspaceToDom(Blockly.mainWorkspace);
  const serializer = new XMLSerializer();
  const xmlStr = serializer.serializeToString(xmlDom);

  // Send put request.
  fetch(url, {
    method: 'PUT',
    body: xmlStr,
  }).then((response) => {
    if (response.ok) {
      Blockly.alert('workspace saved!');
    } else {
      Blockly.alert(`Error saving workspace: 
${response.status}: ${response.statusText}`);
    }
  });
};

/**
 * Bind a function to a button's click event.
 * On touch enabled browsers, ontouchend is treated as equivalent to onclick.
 * @param {!Element|string} el Button element or ID thereof.
 * @param {!Function} func func Event handler to bind.
 */
Blast.bindClick = function(el, func) {
  if (typeof el == 'string') {
    el = document.getElementById(el);
  }
  el.addEventListener('click', func, true);
  el.addEventListener('touchend', func, true);
};

/**
 * Load the Prettify CSS and JavaScript.
 */
Blast.importPrettify = function() {
  const script = document.createElement('script');
  script.setAttribute(
      'src',
      'https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js',
  );
  document.head.appendChild(script);
};

/**
 * Compute the absolute coordinates and dimensions of an HTML element.
 * @param {!Element} element Element to match
 * @return {!Object} Contains heightm, width, x, and y properties.
 * @private
 */
Blast.getBox_ = function(element) {
  const height = element.offsetHeight;
  const width = element.offsetWidth;
  let x = 0;
  let y = 0;
  do {
    x += element.offsetLeft;
    y += element.offsetTop;
    element = element.offsetParent;
  } while (element);
  return {
    height: height,
    width: width,
    x: x,
    y: y,
  };
};

/**
 * List of tab names.
 */
Blast.TABS = ['workspace', 'javascript', 'xml'];

Blast.selected = 'workspace';

/**
 * Compute the absolute coordinates and dimensions of an HTML element.
 * @param {!Element} element Element to match.
 * @return {!Object} Contains height, width, x, and y properties.
 * @private
 */
Blast.getBBox_ = function(element) {
  const height = element.offsetHeight;
  const width = element.offsetWidth;
  let x = 0;
  let y = 0;
  do {
    x += element.offsetLeft;
    y += element.offsetTop;
    element = element.offsetParent;
  } while (element);
  return {
    height: height,
    width: width,
    x: x,
    y: y,
  };
};

/**
 * Switch the visible pane when a tab is clicked.
 * @param {string} clickedName Name of tab clicked.
 */
Blast.tabClick = function(clickedName) {
  // Deselect all tabs and hide all panes.
  for (let i = 0; i < Blast.TABS.length; i++) {
    const name = Blast.TABS[i];
    const tab = document.getElementById('tab_' + name);
    tab.classList.add('taboff');
    tab.classList.remove('tabon');
    document.getElementById('content_' + name).style.visibility = 'hidden';
  }

  // Select the active tab.
  Blast.selected = clickedName;
  const selectedTab = document.getElementById('tab_' + clickedName);
  selectedTab.classList.remove('taboff');
  selectedTab.classList.add('tabon');
  // Show the selected pane.
  document.getElementById('content_' + clickedName).style.visibility =
    'visible';
  Blockly.svgResize(Blast.workspace);
};

/**
 * Populate the JS pane with pretty printed code generated from the blocks.
 */
Blast.renderContent = function() {
  // render the xml content.
  const xmlTextarea = document.getElementById('content_xml');
  const xmlDom = Blockly.Xml.workspaceToDom(Blast.workspace);
  const xmlText = Blockly.Xml.domToPrettyText(xmlDom);
  xmlTextarea.value = xmlText;
  xmlTextarea.focus();

  // render the JavaScript content.
  const content = document.getElementById('content_javascript');
  content.textContent = Blast.latestCode.replace(
      /highlightBlock\('.*'\);\n/gm,
      '',
  );
  // Remove the 'prettyprinted' class, so that Prettify will recalculate.
  content.className = content.className.replace('prettyprinted', '');
  if (typeof PR == 'object') {
    PR.prettyPrint();
  }
};

/**
 * Initialize Blast. Called on page load.
 */
Blast.init = function() {
  // Set remaining properties
  Blast.messageOutputContainer = document.getElementById('msgOutputContainer');
  Blast.runButton = document.getElementById('runButton');
  Blast.statusContainer = document.getElementById('statusContainer');

  const container = document.getElementById('content_area');
  const onresize = function(e) {
    const bBox = Blast.getBBox_(container);
    for (let i = 0; i < Blast.TABS.length; i++) {
      const el = document.getElementById('content_' + Blast.TABS[i]);
      el.style.top = bBox.y + 'px';
      el.style.left = bBox.x + 'px';
      // Height and width need to be set, read back, then set again to
      // compensate for scrollbars.
      el.style.height = bBox.height + 'px';
      el.style.height = 2 * bBox.height - el.offsetHeight + 'px';
      el.style.width = bBox.width + 'px';
      el.style.width = 2 * bBox.width - el.offsetWidth + 'px';
    }
    // Make the 'workspace' tab line up with the toolbox.
    if (Blast.workspace && Blast.workspace.getToolbox().width) {
      document.getElementById('tab_workspace').style.minWidth =
        Blast.workspace.getToolbox().width - 38 + 'px';
      // Account for the 19 pixel margin and on each side.
    }
  };
  window.addEventListener('resize', onresize, false);

  Blast.workspace = Blockly.inject('content_workspace', {
    grid: {spacing: 25, length: 3, colour: '#ccc', snap: true},
    media: 'media/',
    toolbox: defaultToolbox,
    zoom: {controls: true, wheel: true},
  });

  Blast.tabClick(Blast.selected);
  Blast.uriInput = document.getElementById('loadWorkspace-input');
  Blast.uriInput.addEventListener('keyup', (event) => {
    // load blocks from URI on Enter
    if (event.keyCode === 13) {
      Blast.loadBlocks();
    }
  });
  Blast.bindClick('loadButton', Blast.loadBlocks);
  Blast.bindClick('saveButton', Blast.saveBlocks);

  for (let i = 0; i < Blast.TABS.length; i++) {
    const name = Blast.TABS[i];
    Blast.bindClick(
        'tab_' + name,
        (function(name_) {
          return function() {
            Blast.tabClick(name_);
          };
        })(name),
    );
  }

  onresize();
  Blockly.svgResize(Blast.workspace);

  // Load the interpreter now, and upon future changes.
  Blast.generateCode();
  Blast.workspace.addChangeListener(function(event) {
    if (!(event instanceof Blockly.Events.Ui)) {
      // Something changed. Parser needs to be reloaded.
      Blast.resetInterpreter();
      Blast.generateCode();
      Blast.renderContent();
    }
  });

  // Display output hint
  Blast.displayText('Actionblock output will be displayed here');
  // Lazy-load the syntax-highlighting.
  window.setTimeout(Blast.importPrettify, 1);
};

/**
 * Highlight a block with id id.
 * @param {!Blockly.Block.id} id identifier of the block to be highlighted.
 */
Blast.highlightBlock = function(id) {
  Blast.workspace.highlightBlock(id);
  Blast.highlightPause = true;
};

/**
 * Reset the UI.
 * @param {Blast.status} status new Blast status text.
 */
Blast.resetUi = function(status) {
  // remove highlighting
  Blast.workspace.highlightBlock(null);
  Blast.highlightPause = false;
  // set Blast stauts
  Blast.setStatus(status);
};

/**
 * Set the start/stop button and status text
 * @param {Blast.status} status new Blast status text.
 */
Blast.setStatus = function(status) {
  let icon;
  let func;
  let title;
  if (status === 'running') {
    func = Blast.stopJS;
    icon = Blast.stopIcon;
    title = 'Stop the execution';
  } else {
    func = Blast.runJS;
    icon = Blast.playIcon;
    title = 'Run block program';
  }

  // Set start/stop button click event and icon
  Blast.runButton.onclick = func;
  Blast.runButton.title = title;
  Blast.runButton.innerHTML = icon;
  // set status text
  Blast.statusContainer.innerHTML = status;
};

/**
 * Generate JavaScript Code for the user's block-program.
 */
Blast.generateCode = function() {
  Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n';
  Blockly.JavaScript.addReservedWords('highlightBlock');
  // Generate JavaScript code and parse it.
  Blast.latestCode = '';
  Blast.latestCode = Blockly.JavaScript.workspaceToCode(Blast.workspace);

  Blast.resetUi(Blast.status.READY);
};

/**
 * Reset the JS Interpreter.
 */
Blast.resetInterpreter = function() {
  Blast.Interpreter = null;
  if (Blast.runner) {
    clearTimeout(Blast.runner);
    Blast.runner = null;
  }
};

/**
 * Execute the user's code.
 */
Blast.runJS = function() {
  // Reset Ui
  Blast.resetUi(Blast.status.RUNNING);
  if (Blast.Interpreter == null) {
    // And then show generated code in an alert.
    // In a timeout to allow the outputArea.value to reset first.
    setTimeout(function() {
      // Begin execution
      Blast.highlightPause = false;
      Blast.Interpreter = new Interpreter(Blast.latestCode, initApi);
      Blast.runner = function() {
        if (Blast.Interpreter) {
          try {
            const hasMore = Blast.Interpreter.step();
            if (hasMore) {
              // Execution is currently blocked by some async call.
              // Try again later.
              setTimeout(Blast.runner, 5);
            } else {
              // Program is complete.
              Blast.resetUi(Blast.status.READY);
              Blast.resetInterpreter();
            }
          } catch (error) {
            Blockly.alert('Error executing program:\n%e'.replace('%e', error));
            Blast.setStatus(Blast.status.ERROR);
            console.error(error);
          }
        }
      };
      Blast.runner();
    }, 1);
    return;
  }
};

/**
 * Stop the JavaScript execution.
 */
Blast.stopJS = function() {
  Blast.resetInterpreter();
  Blast.resetUi(Blast.status.STOPPED);
};

/**
 * Discard all blocks from the workspace.
 */
Blast.discard = function() {
  const count = Blast.workspace.getAllBlocks(false).length;
  if (
    count < 2 ||
    window.confirm(Blockly.Msg['DELETE_ALL_BLOCKS'].replace('%1', count))
  ) {
    Blast.workspace.clear();
    if (window.location.hash) {
      window.location.hash = '';
    }
  }
};

/**
 * Add a text message to the output container.
 * @param {string} text text message to output.
 */
Blast.displayText = function(text) {
  // Limit messages to 100
  if (Blast.messageCounter > 100) {
    Blast.messageOutputContainer.lastChild.remove();
  }
  // container for the new message
  const msg = document.createElement('div');
  msg.classList.add('message');
  msg.id = 'message-' + Blast.messageCounter++;

  const textNode = document.createTextNode(text);
  msg.appendChild(textNode);

  const timeSpan = document.createElement('span');
  timeSpan.classList.add('time');
  timeSpan.innerHTML = new Date().toLocaleTimeString();
  msg.appendChild(timeSpan);

  // insert new message
  Blast.messageOutputContainer.insertBefore(
      msg,
      Blast.messageOutputContainer.firstChild,
  );
};

/**
 * TODO
 * @param {*} table
 */
Blast.displayTable = function(table) {
  // Limit messages to 100
  if (Blast.messageCounter > 100) {
    Blast.messageOutputContainer.lastChild.remove();
  }
  // display message if table is empty
  if (table.length == 0) {
    Blast.displayText('empty table');
    return;
  }
  // deal with missing values
  const vars = table.reduce((list, res) => {
    for (const v in res) {
      if (list.indexOf(v) === -1) list.push(v);
    }
    return list;
  }, []);
  // Element for new table
  let html = '<tr>';
  vars.forEach((v) => (html += '<th>' + v + '</th>'));
  html += '</tr>';

  table.forEach((res) => {
    html += '<tr>';
    vars.forEach(
        (v) => (html += '<td>' + (res[v] ? res[v].value : '') + '</td>'),
    );
    html += '</tr>';
  });

  const resultsField = document.createElement('table');
  resultsField.classList.add('output_table');
  resultsField.innerHTML = html;
  // insert new table
  Blast.messageOutputContainer.insertBefore(
      resultsField,
      Blast.messageOutputContainer.firstChild,
  );
};
// initialize blast when page dom is loaded
window.addEventListener('load', Blast.init);
