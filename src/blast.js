/**
 * @fileoverview Core JavaScript library for Blast.
 * https://github.com/wintechis/blast
 * @author derwehr@gmail.com (Thomas Wehr)
 * @license https://www.gnu.org/licenses/agpl-3.0.de.html AGPLv3
 */
'use strict';

/**
 * Top level namespace used to access the Blast library.
 * @name Blast
 * @namespace
 */
goog.module('Blast');
goog.module.declareLegacyNamespace();

const {generateEventCode} = goog.require('Blast.States');
const {statesInterpreter} = goog.require('Blast.States');
const {clearIntervalEvents} = goog.require('Blast.States');
const {initUi} = goog.require('Blast.Ui');
const {addMessage} = goog.require('Blast.Ui');
const {setStatus} = goog.require('Blast.Ui');
const {renderContent_} = goog.require('Blast.Ui');
const {currentToolbox} = goog.require('Blast.Toolbox');
const {initToolbox} = goog.require('Blast.Toolbox');

/**
 * Contains configurable parameters of Blast.
 * @property {string} hostAddress - address of the API host.
 */
Blast.config = {};

/**
 * Blast's main workspace.
 * @type {Blockly.workspaceSvg}
 * @public
 */
Blast.workspace = null;

/**
 * is block highlighting paused.
 * @type {boolean}
 * @public
 */
Blast.highlightPause = false;

/**
 * Array of tuples, containg names and functions defined in the things folder,
 * in order to add them to the interpreter API in {@link initAPI}.
 * @type {[string, function][]}
 * @public
 */
Blast.apiFunctions = [];

/**
 * Array of tuples, containg names and asynchronous functions defined in the
 * things folder, in order to add them to the interpreter API in {@link initAPI}.
 * @type {[string, function][]}
 * @public
 */
Blast.asyncApiFunctions = [];

/**
 * latest JavaScript code generated by Blast.
 * @type {string}
 * @public
 */
Blast.latestCode = '';

/**
 * Instance of the JS Interpreter.
 * @type {?Interpreter}
 * @public
 */
Blast.Interpreter = null;

/**
 * Indicates wheter BLAST is current interrupted.
 * @type {boolean}
 * @public
 */
Blast.Interrupted = false;

/**
 * Tracks event blocks currently in the workspace,
 * in order to run indefinately if in case there are any.
 */
Blast.eventInWorkspace = [];

/**
 * Stores event handlers of webHID devices, in order to remove them on code completion.
 */
Blast.deviceEventHandlers = [];

/**
 * Stores functions to invoke to reset, when the interpreter is stopped.
 */
Blast.cleanUpFunctions = [];


/**
 * Instance of runner function.
 * @type {?function}
 * @private
 */
Blast.runner_ = null;

/**
 * Enum for Blast status
 * @enum {string}
 * @public
 */
Blast.status = {
  READY: 'ready',
  RUNNING: 'running',
  STOPPED: 'stopped',
  ERROR: 'error',
};

/**
 * Bind a function to a button's click event.
 * @param {!Element|string} el Button element or ID thereof.
 * @param {!Function} func func Event handler to bind.
 * @public
 */
Blast.bindClick = function(el, func) {
  if (typeof el == 'string') {
    el = document.getElementById(el);
  }
  el.addEventListener('click', func, true);
  el.addEventListener('touchend', func, true);
};

/**
 * Load the Prettify CSS and JavaScript.
 * @public
 */
Blast.importPrettify = function() {
  const script = document.createElement('script');
  script.setAttribute(
      'src',
      'https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js',
  );
  document.head.appendChild(script);
};

/**
 * Compute the absolute coordinates and dimensions of an HTML element.
 * @param {!Element} element Element to match.
 * @return {!Object} Contains height, width, x, and y properties.
 * @private
 */
Blast.getBBox_ = function(element) {
  const height = element.offsetHeight;
  const width = element.offsetWidth;
  let x = 0;
  let y = 0;
  do {
    x += element.offsetLeft;
    y += element.offsetTop;
    element = element.offsetParent;
  } while (element);
  return {
    height: height,
    width: width,
    x: x,
    y: y,
  };
};

/**
 * Initialize Blast. Called on page load.
 * @public
 */
Blast.init = function() {
  // mobile website has its own init
  if (window.location.href.includes('mobile')) {
    return;
  }

  Blast.workspace = Blockly.inject('content_workspace', {
    // grid: {spacing: 25, length: 3, colour: '#ccc', snap: true},
    media: 'media/',
    toolbox: currentToolbox,
    zoom: {controls: true, wheel: true},
  });

  // initialize toolbox
  initToolbox();

  Blockly.svgResize(Blast.workspace);

  // Initialize UI
  initUi();
  setStatus(Blast.status.READY);
  // Load the interpreter now, and upon future changes.
  Blast.generateCode();
  Blast.workspace.addChangeListener(function(event) {
    if (!(event instanceof Blockly.Events.Ui)) {
      // Something changed. Parser needs to be reloaded.
      Blast.generateCode();
      generateEventCode();
      renderContent_();
    }
  });

  // Display output hint
  addMessage('Actionblock output will be displayed here', 'info');
  // Lazy-load the syntax-highlighting.
  window.setTimeout(Blast.importPrettify, 1);
};

/**
 * Highlight a block with id id.
 * @param {!Blockly.Block.id} id identifier of the block to be highlighted.
 * @public
 */
Blast.highlightBlock = function(id) {
  Blast.workspace.highlightBlock(id);
  Blast.highlightPause = true;
};

// TODO: move to UI module
/**
 * Reset the UI.
 * @param {Blast.status} status new Blast status text.
 * @public
 */
Blast.resetUi = function(status) {
  // remove highlighting
  Blast.workspace.highlightBlock(null);
  Blast.highlightPause = false;
  // set Blast stauts
  setStatus(status);
};

/**
 * Generate JavaScript Code for the user's block-program.
 * @public
 */
Blast.generateCode = function() {
  Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n';
  Blockly.JavaScript.addReservedWords('highlightBlock');
  // Generate JavaScript code and parse it.
  Blast.latestCode = '';
  Blast.latestCode = Blockly.JavaScript.workspaceToCode(Blast.workspace);
};

/**
 * Reset the JS Interpreter.
 * @public
 */
Blast.resetInterpreter = function() {
  Blast.Interpreter = null;
  if (Blast.runner_) {
    clearTimeout(Blast.runner_);
    Blast.runner_ = null;
  }
  Blast.Bluetooth.tearDown();
  Blast.removeDeviceHandlers();
  clearIntervalEvents();
  
  for (const func of Blast.cleanUpFunctions) {
    func();
  }
};

/**
 * removes all event handlers of webHID devices from {@link Blast.deviceEventHandlers}
 */
Blast.removeDeviceHandlers = function() {
  for (const handler of Blast.deviceEventHandlers) {
    const device = handler.device;
    device.removeEventListener(handler.type, handler.fn);
  }
  Blast.deviceEventHandlers = [];
};

/**
 * Execute the user's code.
 * @public
 */
Blast.runJS = function() {
  // Reset Ui
  Blast.resetUi(Blast.status.RUNNING);
  addMessage('execution started', 'info');
  if (Blast.Interpreter == null) {
    // Begin execution
    Blast.highlightPause = false;
    Blast.Interpreter = new Interpreter(Blast.latestCode, initApi);

    /**
     * executes {@link Blast.latestCode} using {@link Blast.Interpreter}.
     * @function runner_
     * @memberof Blast#
     */
    Blast.runner_ = function() {
      if (Blast.Interpreter) {
        try {
          if (Blast.Interrupted) {
            // Execution is currently interrupted, try again later.
            setTimeout(Blast.runner_, 1);
          } else {
            const hasMore = Blast.Interpreter.step();
            if (hasMore) {
              // Execution is currently blocked by some async call.
              // Try again later.
              setTimeout(Blast.runner_, 1);
            } else if (statesInterpreter || Blast.eventInWorkspace.length > 0) {
              // eventChecker is running,
              // dont reset UI until stop button is clicked.
            } else {
              // Program is complete.
              Blast.resetUi(Blast.status.READY);
              addMessage('execution completed', 'info');
              Blast.resetInterpreter();
            }
          }
        } catch (error) {
          Blast.throwError(error);
          Blast.resetInterpreter();
          console.error(error);
        }
      }
    };

    Blast.runner_();
  }
};

/**
 * Stop the JavaScript execution.
 * @public
 */
Blast.stopJS = function() {
  Blast.resetInterpreter();
  if (statesInterpreter) {
    Blast.States.resetInterpreter();
  }
  Blast.resetUi(Blast.status.STOPPED);
};

/**
 * Stop execution and adds an error message to the
 * {@link Blast.messageOutputContainer}.
 * @param {string=} text optional, a custom error text
 * @license https://www.gnu.org/licenses/agpl-3.0.de.html AGPLv3
 */
Blast.throwError = function(text) {
  if (!text) {
    text = 'Error executing program - See console for details.';
  }

  addMessage(text, 'error');
  setStatus(Blast.status.ERROR);
  Blast.resetInterpreter();
  addMessage('Execution stopped', 'info');
};

/**
 * Helper function checking fetch's response status.
 * Returns the response object if it was successfull.
 * Otherwise it throws an error.
 * @param {Object} response A fetch response object.
 * @param {string=} message Alert message, optional.
 * @return {Object} the response object
 */
Blast.handleFetchErrors = function(response, message) {
  if (!response.ok) {
    if (!message) {
      Blast.throwError('Error processing HTTP Request.');
    } else {
      Blast.throwError(message);
    }
  }
  return response;
};

// initialize blast when page dom is loaded
window.addEventListener('load', Blast.init);
